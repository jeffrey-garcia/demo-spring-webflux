spring:
  cloud:
    function:
      # control which function method in our code will be triggered if there are multiple
      definition: supplierRx0;consumerRx0;
#      definition: supplierRx1;consumerRx1;
#      definition: supplierRx2;consumerRx2;
#      definition: supplier0;consumer0;
#      definition: supplierRx0;consumerRx0;supplier0;consumer0;
#      definition: supplierRx0;consumerRx0;supplier2;consumer2;
      # use pipe symbol to dynamically compose multiple handlers to form simple function
#      definition: supplier1|toUpperCase;toLowerCase|consumer1;
#      definition: supplierRx2|wrapDoubleQuotes;unwrapDoubleQuotes|consumerRx2;
#      routing:
#        # explicit enablement of routing function
#        # routing function will be bound to input destination receiving all the messages and
#        # route them to other functions based on the provided instruction in message header
#        enabled: true
    stream:
      # trigger the creation of StreamBridge bean
      # specify the supplier and consumer function name that will used by StreamBridge bean
      # to send data to the output channel
      # [IMPORTANT]
      # - the provided function names must also be defined in spring.cloud.function.definition
      # - the provided function names must also be defined with its associate channel bindings in spring.cloud.stream.bindings
      source: supplier2;consumer2;
#      function:
#        # use descriptive binding names allowing other configuration properties to refer to that binding name
#        # [IMPORTANT] somehow this is not working properly with SCSt v3.0.3
#        bindings:
#          supplier|toUpperCase: supplierCompose
#          toLowerCase|consumer: consumerCompose
      poller:
        # increase or decrease the rate of message production (1000 = 1s)
        fixed-delay: 60000
      rabbit:
        bindings:
          supplierRx0-out-0:
            producer:
              confirmAckChannel: publisher-confirm
          consumerRx0-in-0:
            consumer:
              # dlx/dlq setup
              # When DLQ is configured, failed messages are sent to this destination for
              # subsequent re-processing or auditing and reconciliation.
              # if no DLQ is provided, by default the messaging system drops the failed message.
              autoBindDlq: true
              # The backoff time to wait between re-deliveries
              # when the backoff time expired, message from the DLQ are routed back to original queue
              dlqTtl: 15000
              # The dlqDeadLetterExchange property is specified with no value,
              # which means route expired messages to the default exchange DLX
              dlqDeadLetterExchange:
              # When maxAttempt = 1 (internal retry disabled) AND requeueRejected = true
              # any rejected/failed message will be re-queued and retry exhaustively
              # When DLQ is configured, set requeueRejected = false such that any exception thrown
              # can cause the rejected/failed message to be routed to DLQ instead of infinite retry
              requeueRejected: false
      bindings:
        supplierRx0-out-0:
          destination: demofunc-exchange-rx0
          group: demofunc-queue-rx0
          contentType: application/json
          binder: local_rabbit
          producer:
            errorChannelEnabled: true
        consumerRx0-in-0:
          destination: demofunc-exchange-rx0
          contentType: application/json
          group: demofunc-queue-rx0
          binder: local_rabbit
          consumer:
            # Disable default binder retry
            # if not configured, default binder will assume 3 attempts before it considered the retries are exhausted
            # if set to 1, binder internal retry will be disabled and message are routed to DLQ right-away when any exception
            maxAttempts: 1
#        supplierRx1-out-0:
#          destination: demofunc-exchange-rx1
#          group: demofunc-queue-rx1
#          binder: local_rabbit
#        consumerRx1-in-0:
#          destination: demofunc-exchange-rx1
#          group: demofunc-queue-rx1
#          binder: local_rabbit
#        supplierRx2-out-0:
#          destination: demofunc-exchange-rx2
#          group: demofunc-queue-rx2
#          binder: local_rabbit
#        consumerRx2-in-0:
#          destination: demofunc-exchange-rx2
#          group: demofunc-queue-rx2
#          binder: local_rabbit
#        supplier0-out-0:
#          destination: demofunc-exchange-0
#          group: demofunc-queue-0
#          binder: local_rabbit
#        consumer0-in-0:
#          destination: demofunc-exchange-0
#          group: demofunc-queue-0
#          binder: local_rabbit
#        supplier0|toUpperCase-out-0:
#          destination: demoComp-exchange-0
#          group: demoComp-queue-0
#          binder: local_rabbit
#        toLowerCase|consumer1-in-0:
#          destination: demoComp-exchange-0
#          group: demoComp-queue-0
#          binder: local_rabbit
#        supplierRx2|wrapDoubleQuotes-out-0:
#          destination: demoComp-exchange-rx0
#          group: demoComp-queue-rx0
#          binder: local_rabbit
#        unwrapDoubleQuotes|consumerRx2-in-0:
#          destination: demoComp-exchange-rx0
#          group: demoComp-queue-rx0
#          binder: local_rabbit
#        supplier2-out-0:
#          destination: demofunc-exchange-2
#          group: demofunc-queue-2
#          binder: local_rabbit
#        consumer2-in-0:
#          destination: demofunc-exchange-2
#          group: demofunc-queue-2
#          binder: local_rabbit
      binders:
        # Local RabbitMQ binder config
        local_rabbit:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                # Connect to RabbitMQ cluster and fail-over at the client-side regardless a HA-proxy
                addresses: localhost:5674,localhost:5672
                username: guest
                password: guest
                connectionTimeout: 60000
                # Requested heartbeat timeout, in seconds; zero for none.
                requestedHeartbeat: 15000
                # Configure the connection factory to provide acknowledgement to publishers
                # - guarantee message is not lost during sending to broker cause
                # - if the broker is unable to store a message it will return a nack asynchronously
                #   and refuses responsibility of it, the client could choose to apply retry strategy
                #   or report the failure to upstream
                publisherConfirms: true
                publisherReturns: true

com:
  jeffrey:
    example:
      messaging:
        enabled: true
      eventstore:
        enabled: true
        mongo:
          collectionPrefix: DemoEventStoreV4
        timezone: Asia/Hong_Kong
      gracefulShutdown:
        enabled: true
        shutdownHook:
          # Shutdown hook timeout in milliseconds (should be larger than Hystrix command execution timeout
          # to ensure that the shutdown does not happen earlier than the last request is completed/fallback by hystrix
          timeoutMillis: 10000